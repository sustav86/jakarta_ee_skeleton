#Упорядочение связей
При связях «один ко многим» или «многие ко многим» ваши сущности имеют дело
с коллекциями объектов. На стороне Java эти коллекции обычно неупорядочены.
В таблицах реляционных баз данных тоже не соблюдается какой-либо порядок. Сле-
довательно, если у вас возникнет необходимость в упорядоченном списке, то вам
придется либо отсортировать свою коллекцию программным путем, либо воспользо-
ваться JPQL-запросом с предложением ORDER BY. У JPA имеются более простые ме-
ханизмы, основанные на аннотациях, которые могут помочь в упорядочении связей.
* @OrderBy

Динамическое упорядочение может быть обеспечено благодаря аннотации @OrderBy.
«Динамическое» оно потому, что вы упорядочиваете элементы коллекции при из-
влечении ассоциации.

В примере приложения CD-BookStore пользователям предоставляется возмож-
ность писать новости омузыке и книгах. Эти новости затем выкладываются на сайте,
а после их публикации люди могут добавлять к ним комментарии (листинг 5.50). Вам
необходимо, чтобы комментарии выводились на сайте в хронологическом порядке.
```xml
@Entity
public class Comment {
    @Id @GeneratedValue
    private Long id;
    private String nickname;
    private String content;
    private Integer note;
    @Column(name = "posted_date")
    @Temporal(TemporalType.TIMESTAMP)
    private Date postedDate;
// Конструкторы, геттеры, сеттеры
}
```
Комментарии моделируются с использованием сущности Comment, показанной
в листинге 5.50. У нее имеется content, она размещается пользователем (идентифи-
цируется параметром nickname), оставляющим примечания к новостям, кроме того,
она располагает postedDate типа TIMESTAMP, который автоматически создается систе-
мой. В случае с сущностью News, показанной в листинге 5.51, вы захотите иметь
возможность упорядочивать список комментариев согласно дате их размещения
в убывающем порядке. Для этого вам потребуется прибегнуть к аннотации @OrderBy
в сочетании с аннотацией @OneToMany.
```xml
@Entity
public class News {
    @Id @GeneratedValue
    private Long id;
    @Column(nullable = false)
    private String content;
    @OneToMany(fetch = FetchType.EAGER)
    @OrderBy("postedDate DESC")
    private List<Comment> comments;
// Конструкторы, геттеры, сеттеры
}
```
Аннотация @OrderBy принимает имена атрибутов, которые должны быть отсор-
тированы (атрибут postedDate), а также метод (сортировка в возрастающем или
убывающем порядке). Строка ASC или DESC может быть использована для обеспе-
чения сортировки соответственно либо в возрастающем, либо в убывающем по-
рядке. Аннотация @OrderBy может охватывать несколько столбцов. Если вам по-
требуется выполнить упорядочение согласно дате размещения и примечаниям, то
вы сможете воспользоваться OrderBy("postedDate DESC, note ASC").

Аннотация @OrderBy никак не влияет на отображение базы данных. Поставщик
постоянства просто информируется о необходимости использовать предложение
ORDER BY при извлечении коллекции во время выполнения.

* @OrderColumn

Версия JPA 1.0 позволяла осуществлять динамическое упорядочение с использо-
ванием аннотации @OrderBy, однако не предусматривала возможности поддерживать
постоянное упорядочение. С выходом JPA 2.0 это стало возможным благодаря до-
бавлению аннотации @OrderColumn (ее API-интерфейс схож с API-интерфейсом
аннотации @Column из листинга 5.12). Эта аннотация информирует поставщика по-
стоянства о том, что он должен обеспечить поддержку упорядоченного списка
с использованием отдельного столбца, в котором располагается индекс. @OrderColumn
определяет этот отдельный столбец.

Воспользуемся примером сущностей News и Comment и немного изменим его.
На этот раз у сущности Comment, показанной в листинге 5.52, не будет атрибута
postedDate и, следовательно, сортировка комментариев в хронологическом порядке
окажется невозможной.
```xml
@Entity
public class Comment {
    @Id @GeneratedValue
    private Long id;
    private String nickname;
    private String content;
    private Integer note;
// Конструкторы, геттеры, сеттеры
}
```
Для сохранения сортировки без даты размещения в случае с сущностью News
(показанной в листинге 5.53) можно аннотировать связь с помощью @OrderColumn.
Тогда поставщик постоянства отобразит сущность News в таблицу с дополнительным
столбцом для сохранения сортировки.
```xml
@Entity
public class News {
    @Id @GeneratedValue
    private Long id;
    @Column(nullable = false)
    private String content;
    @OneToMany(fetch = FetchType.EAGER)
    @OrderColumn(name = "posted_index")
    private List<Comment> comments;
// Конструкторы, геттеры, сеттеры
}
```
В листинге 5.53 @OrderColumn переименовывает дополнительный столбец в POSTED_
INDEX. Если это имя не будет изменено, то по умолчанию имя столбца будет пред-
ставлять собой конкатенацию имени атрибута сущности и строки _ORDER (COMMENTS_
ORDER в нашем примере). Этот столбец должен иметь числовой тип. Соответствующая
упорядоченная связь будет отображена в отдельную таблицу соединения, как по-
казано далее:
```xml
create table NEWS_COMMENT (
NEWS_ID BIGINT not null,
COMMENTS_ID BIGINT not null,
POSTED_INDEX INTEGER
);
```
Есть особенности, влияющие на производительность, о которых вам следует
знать; как и в случае с аннотацией @OrderColumn, поставщик постоянства должен
отслеживать изменения индекса. Он отвечает за поддержку порядка при вставке,
удалении и переупорядочении. Если информация окажется вставлена в середину
уже существующего отсортированного списка данных, то поставщику постоянства
придется переупорядочить весь индекс.

Переносимым приложениям не следует ожидать, что список будет упорядочен
базой данных, предполагая, что движки некоторых баз данных автоматически
оптимизируют их индексы, благодаря чему таблица данных выглядит отсортиро-
ванной. Вместо этого для них следует использовать конструкцию @OrderColumn либо
@OrderBy. Нужно отметить, что вы не сможете одновременно задействовать обе эти
аннотации.
