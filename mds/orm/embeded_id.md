#@EmbeddedId
Как вы еще увидите позднее в этой главе, JPA использует встро-
енные объекты разных типов. Резюмируя, отмечу, что у встроенного объекта нет
какого-либо идентификатора (собственного первичного ключа), а его атрибуты
в итоге окажутся столбцами таблицы содержащей их сущности.
В листинге 5.5 класс NewsId показан как встраиваемый. Он представляет собой
всего лишь встроенный объект (аннотированный с использованием @Embeddable),
который в данном случае включает два атрибута (title и language). У этого класса
должен быть конструктор без аргументов, геттер, сеттер, а также реализации equals()
и hashCode(). Это означает, что он должен придерживаться соглашений JavaBeans.
У этого класса как такового нет собственного идентификатора (отсутствует анно-
тация @Id). Это характерно для встраиваемых классов.
```xml
@Embeddable
public class NewsId {
    private String title;
    private String language;
// Конструкторы, геттеры, сеттеры
}
```
В случае с сущностью News, показанной в листинге 5.6, затем придется встроить
класс первичного ключа NewsId с применением аннотации @EmbeddedId. Благодаря
такому подходу не потребуется использовать @Id. Каждая аннотация @EmbeddedId
должна ссылаться на встраиваемый класс, помеченный @Embeddable.
```xml
@Entity
public class News {
    @EmbeddedId
    private NewsId id;
    private String content;
// Конструкторы, геттеры, сеттеры
}
```
В следующей главе я опишу, как находить сущности с использованием их пер-
вичного ключа. Вот первый, но мимолетный взгляд на то, как это происходит: пер-
вичный ключ — это класс с конструктором. Вам придется создать экземпляр этого
класса со значениями, формирующими ваш уникальный ключ, и передать соответ-
ствующий объект менеджера сущностей (атрибут em), как показано в этом коде:
```xml
NewsId pk = new NewsId("Richard Wright has died on September 2008", "EN")
News news = em.find(News.class, pk);
```
