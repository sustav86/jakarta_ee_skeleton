#Составные первичные ключи
При отображении сущностей правильным подходом будет обозначить один специ-
ально отведенный для этого столбец как первичный ключ. Однако бывают ситуации,
когда требуется составной первичный ключ (скажем, если приходится выполнять
отображение в унаследованную базу данных или первичные ключи должны придер-
живаться определенных бизнес-правил — например, необходимо включить значение
или код страны и отметку времени). Для этого должен быть определен класс первич-
ного ключа, который будет представлять составной ключ. Кроме того, у нас есть две
доступные аннотации для определения этого класса в зависимости от того, как мы
хотим структурировать сущность: 
* @EmbeddedId и @IdClass. 

Как вы еще увидите, конечный
результат будет одинаковым и в итоге у вас окажется одна и та же схема базы данных,
однако способы выполнения запросов к сущности будут немного различаться.

Например, приложению CD-BookStore необходимо часто выкладывать инфор-
мацию на главной странице, где вы сможете читать ежедневные новости о книгах,
музыке или артистах. У новостей будет иметься содержимое, название и, посколь-
ку они могут быть написаны на нескольких языках, код языка (EN для английского,
PT — для португальского и т. д.). Первичным ключом для новостей тогда сможет
быть название и код языка, поскольку статья может быть переведена на разные
языки, но с сохранением ее оригинального названия. Таким образом, класс первич-
ного ключа NewsId будет включать два атрибута, имеющие тип String: title и language.
Классы первичных ключей должны включать определения методов для equals()
и hashCode() для управления запросами и внутренними коллекциями (равенство
в случае с этими методами должно быть таким же, как и равенство, которое имеет
место в случае с базой данных), а их атрибуты должны быть допустимых типов,
входящих в приведенный ранее набор. Они также должны быть открытыми, реа-
лизовывать интерфейс Serializable, если им потребуется пересекать архитектурные
уровни (например, управление ими будет осуществляться на постоянном уровне,
а использование — на уровне представления), и располагать конструктором без
аргументов.
