#Резюме

Благодаря конфигурации в порядке исключения немногое требуется для того,
чтобы отобразить сущности в таблицах. Проинформируйте поставщика постоянства
о том, что класс на самом деле является сущностью (посредством @Entity), атри-
бут — его идентификатором (посредством @Id), а JPA сделает все остальное. Эта
глава могла бы быть намного короче, если бы мы придерживались в ней только
того, что применяется по умолчанию. JPA обладает очень богатым набором анно-
таций для настройки всех мелких деталей объектно-реляционного отображения
(а также эквивалентного XML-отображения).

Элементарные аннотации могут быть использованы в отношении атрибутов
(@Basic, @Temporal и т. д.) или классов для настройки отображения. Вы можете
изменить имя таблицы либо тип первичного ключа или даже избегать отображе-
ния с помощью аннотации @Transient. Применяя JPA, вы можете отображать
коллекции базовых типов или встраиваемых объектов. В зависимости от своей
бизнес-модели вы можете отображать связи (@OneToOne, @ManyToMany и т. д.) с раз-
ными направлениями и множественностью. То же самое касается и наследования
(@Inheritance, @MappedSuperclass и т. д.), при котором допустимо использовать
разные стратегии для отображения иерархий, где смешаны сущности и классы,
не являющиеся сущностями.

В этой главе внимание было сосредоточено на статической части JPA, или
на том, как отображать сущности в таблицах. В следующей главе рассматрива-
ются динамические темы: как управлять этими сущностями и выполнять к ним
запросы.