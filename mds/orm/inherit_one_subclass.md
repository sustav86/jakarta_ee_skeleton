#Стратегия «соединенный подкласс»

При использовании стратегии «соединенный подкласс» каждая сущность в иерар-
хии отображается в свою таблицу. Корневая сущность отображается в таблицу,
которая определяет первичный ключ, подлежащий использованию всеми табли-
цами в иерархии, а также столбец дискриминатора. Каждый подкласс представля-
ется с помощью отдельной таблицы, содержащей его атрибуты (не унаследованные
от корневого класса) и первичный ключ, который ссылается на первичный ключ
корневой таблицы. Таблицы, не являющиеся корневыми, не содержат столбец дис-
криминатора.

Вы можете реализовать стратегию «соединенный подкласс», снабдив корневую
сущность аннотацией @Inheritance, как показано в листинге 5.60 (код CD и Book
останется таким же, как и раньше).
```xml
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public class Item {
    @Id @GeneratedValue
    protected Long id;
    protected String title;
    protected Float price;
    protected String description;
// Конструкторы, геттеры, сеттеры
}
```
С точки зрения разработчика, стратегия «соединенный подкласс» естественна,
поскольку состояния всех сущностей, абстрактных или конкретных, будут ото-
бражаться в разные таблицы. На рис. 5.25 показано, как будут отображены сущ-
ности Item, Book и CD.

Вы по-прежнему сможете использовать аннотации @DiscriminatorColumn и @Disc-
riminatorValue в случае с корневой сущностью для настройки столбца дискрими-
натора и изменения значений (столбец DTYPE располагается в таблице ITEM).

Стратегия «соединенный подкласс» интуитивно понятна и близка к тому, что
вы знаете, исходя из механизма объектного наследования. Однако выполнение
запросов может влиять на производительность. В названии этой стратегии при-
сутствует слово «соединенный», так как для повторной сборки экземпляра под-
класса таблицу подкласса необходимо соединить с таблицей корневого класса.

Чем глубже иерархия, тем больше соединений потребуется для сборки листовой
сущности. Эта стратегия хорошо поддерживает полиморфные связи, однако тре-
бует, чтобы при создании экземпляров подклассов сущностей была проведена одна
или несколько операций соединения. Это может привести к низкой производи-
тельности в случае с обширными иерархиями классов. Аналогичным образом
запросы, которые охватывают всю иерархию классов, требуют проведения опера-
ций соединения между таблицами подклассов, приводящих к снижению произво-
дительности.