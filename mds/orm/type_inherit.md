#Типы классов в иерархии наследования

В примерах, приводившихся ранее для объяснения стратегий отображения, были
задействованы только сущности. Item, как и Book и CD, является сущностью. Однако
сущностям не всегда приходится наследовать от сущностей. В иерархии классов
могут быть смешаны всевозможные разные классы: сущности, а также классы,
которые не являются сущностями (или временные классы), абстрактные сущности
и отображенные суперклассы. Наследование от этих классов разных типов будет
влиять на отображение.

##Абстрактная сущность
В приведенных ранее примерах сущность Item представляла собой конкретный
класс. Она была снабжена аннотацией @Entity и не имела ключевого слова abstract,
однако абстрактный класс тоже может быть определен как сущность. Абстрактная
сущность отличается от конкретной только тем, что нельзя непосредственно создать
ее экземпляр с помощью ключевого слова new. Она обеспечивает общую структуру
данных для своих листовых сущностей (Book и CD) и придерживается соответ-
ствующих стратегий отображения. Для поставщика постоянства абстрактная сущ-
ность отображается как обычная сущность. Единственное отличие заключается
в пространстве Java, а не в отображении.

##Класс, который не является сущностью
Классы, которые не являются сущностями, также называют временными, а это
означает, что они представляют собой POJO. Сущность может выступать подклас-
сом по отношению к классу, который не является сущностью, либо такой класс
может расширять ее. Зачем вам могут понадобиться в иерархии классы, которые
не являются сущностями? Объектное моделирование и наследование — это ин-
струменты, с помощью которых совместно используются состояния и поведения.
Классы, которые не являются сущностями, могут применяться для обеспечения
общей структуры данных для листовых сущностей. Состояние суперкласса, не
являеющегося сущностью, непостоянно, поскольку не управляется поставщиком
постоянства (помните, что условием для того, чтобы класс управлялся поставщи-
ком постоянства, является наличие аннотации @Entity).

Например, Book представляет собой сущность (листинг 5.65) и расширяет
Item, который не является сущностью (у Item нет аннотаций), как показано
в листинге 5.64.
```xml
public class Item {
    protected String title;
    protected Float price;
    protected String description;
// Конструкторы, геттеры, сеттеры
}
```
Сущность Book (см. листинг 5.65) наследует от Item, поэтому Java-код может
получить доступ к атрибутам title, price и description, а также к любому другому
методу, который определен обычным, объектно-ориентированным, путем. Item
может быть конкретным или абстрактным и не влияет на финальное отображе-
ние.
```xml
@Entity
public class Book extends Item {
    @Id @GeneratedValue
    private Long id;
    private String isbn;
    private String publisher;
    private Integer nbOfPage;
    private Boolean illustrations;
// Конструкторы, геттеры, сеттеры
}
```
Класс Book является сущностью и наследует от Item. Однако в таблице были бы
отображены только атрибуты Book. Атрибуты Item в структуре таблицы, определен-
ной в листинге 5.66, отсутствуют. Чтобы обеспечить постоянство Book, вам потре-
буется создать экземпляр Book, задать значения для любых атрибутов по вашему
желанию (title, price, isbn, publisher и т. д.), однако будет обеспечено постоянство
только атрибутов Book (id, isbn и т. д.).
```xml
create table BOOK (
ID BIGINT not null,
ILLUSTRATIONS SMALLINT,
ISBN VARCHAR(255),
NBOFPAGE INTEGER,
PUBLISHER VARCHAR(255),
primary key (ID)
);
```

##Отображенный суперкласс

JPA определяет особый тип классов, называемых отображенными суперклассами,
для совместного использования состояний и поведений, а также информации об
отображении, которые от них наследуют сущности. Однако отображенные супер-
классы не являются сущностями. Они не управляются поставщиком постоянства,
у них нет какой-либо таблицы для отображения в нее, к ним нельзя выполнять
запросы и они не могут состоять в связях, однако должны обеспечивать постоянные
свойства для любых сущностей, которые расширяют их. Они аналогичны встраи-
ваемым классам за исключением того, что могут быть использованы в сочетании
с наследованием. Чтобы показать, что класс является отображенным суперклассом,
нужно снабдить его аннотацией 
* @MappedSuperclass.

При использовании корневого класса Item снабжается аннотацией 
@MappedSuperclass, а не @Entity, как показано в листинге 5.67. В данном случае определяет-
ся стратегия наследования (JOINED), а также аннотируются некоторые из его атри-
бутов с использованием @Column. Однако, поскольку отображенные суперклассы не
отображаются в таблицах, не допускается применять аннотацию @Table.
```xml
@MappedSuperclass
@Inheritance(strategy = InheritanceType.JOINED)
public class Item {
    @Id @GeneratedValue
    protected Long id;
    @Column(length = 50, nullable = false)
    protected String title;
    protected Float price;
    @Column(length = 2000)
    protected String description;
// Конструкторы, геттеры, сеттеры
}
```
Как вы можете видеть в листинге 5.67, атрибуты title и description снабжены
аннотацией @Column. В листинге 5.68 показана сущность Book, расширяющая Item.
```xml
@Entity
public class Book extends Item {
    private String isbn;
    private String publisher;
    private Integer nbOfPage;
    private Boolean illustrations;
// Конструкторы, геттеры, сеттеры
}
```
Эта иерархия будет отображена только в одну таблицу. Item не является сущ-
ностью и не содержит таблиц. Атрибуты Item и Book были бы отображены в столбцы
таблицы BOOK, кроме того, отображенные суперклассы также совместно используют
свою информацию об отображении. Аннотации @Column отображенного суперклас-
са Item будут унаследованы. Однако, поскольку такие суперклассы не являются
сущностями, которые находятся под управлением, вы не смогли бы, к примеру,
обеспечить их постоянство или выполнять к ним запросы. В листинге 5.69 показа-
на структура таблицы BOOK с настроенными столбцами TITLE и DESCRIPTION.
```xml
create table BOOK (
ID BIGINT not null,
TITLE VARCHAR(50) not null,
PRICE DOUBLE(52, 0),
DESCRIPTION VARCHAR(2000),
ILLUSTRATIONS SMALLINT,
ISBN VARCHAR(255),
NBOFPAGE INTEGER,
PUBLISHER VARCHAR(255),
primary key (ID)
);
```
