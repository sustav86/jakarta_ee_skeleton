#Написание ограничений
* В листинге 3.1 показано, насколько просто добавлять ограничения в бизнес-модель.
```xml
    public class Book {
        @NotNull
        private String title;
        @NotNull @Min(2)
        private Float price;
        @Size(max = 2000)
        private String description;
        private String isbn;
        private Integer nbOfPage;
        // Конструкторы, геттеры, сеттеры
    }
```
##Внутренняя организация ограничения
* Ограничение определяется как комбинация ограничивающей аннотации и списка
реализаций валидации ограничения.
* Ограничивающая аннотация применяется
с типами, методами, полями или другими ограничивающими аннотациями (в слу-
чае с составными элементами).
* Известно, что ограничение при валидации компонентов состоит из:
    * аннотации, определяющей ограничение;
    * списка классов, реализующих ограничивающий алгоритм с заданным типом.
###Ограничивающая аннотация
Ограничение, применяемое с JavaBean, выражается спомощью одной или нескольких
аннотаций. Аннотация считается ограничивающей, если применяемая в ней полити-
ка хранения содержит RUNTIME иесли сама она аннотирована javax.validation.Constraint
(эта аннотация ссылается на список реализаций валидации). В листинге 3.2 показана
ограничивающая аннотация NotNull. Как видите, @Constraint(validatedBy = {}) указы-
вает на класс реализации NotNullValidator.
```xml
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER})
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = NotNullValidator.class)
public @interface NotNull {
    String message() default "{javax.validation.constraints.NotNull.message}";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```
* Ограничивающие аннотации — это самые обычные аннотации, поэтому с ними
приходится определять своеобразные метааннотации:
    * @Target({METHOD, FIELD, ...}) — указывает цель, для которой может использо-
ваться аннотация (подробнее об этом — ниже);
    * @Retention(RUNTIME) — определяет, как мы будем обращаться с аннотацией. Не-
обходимо использовать как минимум RUNTIME, чтобы поставщик мог проверять
ваш объект во время выполнения;
     * @Constraint(validatedBy = NotNullValidator.class) — указывает класс (в случае
агрегации ограничений — нуль либо список классов), в котором инкапсулирован
валидационный алгоритм;
    * @Documented — определяет, будет эта аннотация включена в Javadoc или нет.
Опциональная метааннотация.
* Поверх этих общих метааннотаций спецификация Bean Validation требует за-
давать для каждой ограничивающей аннотации три дополнительных атрибута:
    * message — обеспечивает для аннотации возможность возвращения интернацио-
нализированного сообщения об ошибке, выдаваемого в том случае, если огра-
ничение недопустимо. По умолчанию данный атрибут равен ключу;
    * groups — используется для контроля за порядком, в котором интерпретируются
ограничения, либо для выполнения частичной валидации;
    * payload — применяется для ассоциирования метаинформации с ограниче-
нием.
* Если ваше ограничение определяет все обязательные метааннотации и ограни-
чения, можете добавить любой интересующий вас конкретный параметр. Например,
ограничение, проверяющее длину строки, может использовать атрибут length для
указания максимальной длины.
###Реализация ограничений
* Ограничение определяется комбинацией самой аннотации и нуля или более клас-
сов реализации. Классы реализации указываются элементом validatedBy в @Constraint
(как показано в листинге 3.2). Листинг 3.3 демонстрирует класс реализации для
аннотации @NotNull. Как видите, он реализует интерфейс ConstraintValidator и ис-
пользует дженерики для передачи имени аннотации (NotNull) и типа, к которому
применяется аннотация (в данном случае это Object).
```xml
public class NotNullValidator implements ConstraintValidator<NotNull, Object>
{
    public void initialize(NotNull parameters) {
    }
    public boolean isValid(Object object, ConstraintValidatorContext context) {
        return object != null;
    }
}
```
Интерфейс ConstraintValidator определяет два метода, которые обязательны для
реализации конкретными классами.
* initialize — вызывается поставщиком валидации компонентов еще до приме-
нения какого-либо ограничения. Именно здесь мы обычно инициализируем
любые параметры ограничения, если они имеются.
* isValid — здесь реализуется валидационный алгоритм. Метод интерпретирует-
ся поставщиком валидации компонентов всякий раз, когда проверяется кон-
кретное значение. Метод возвращает false, если значение является недопусти-
мым, в противном случае — true. Объект ConstraintValidatorContext несет
информацию и операции, доступные в том контексте, к которому применяется
ограничение.

Реализация ограничения выполняет валидацию заданной аннотации для
указанного типа. В листинге 3.3 ограничение @NotNull типизируется к Object (это
означает, что данное ограничение может использоваться с любым типом дан-
ных). Но у вас может быть и такая ограничивающая аннотация, которая при-
меняет различные алгоритмы валидации в зависимости от того, об обработке
какого типа данных идет речь. Например, вы можете проверять максимальное
количество символов для String, максимальное количество знаков для BigDecimal
или максимальное количество элементов для Collection. Обратите внимание:
в следующей аннотации у нас несколько реализаций одной и той же аннотации
(@Size), но она используется с разными типами данных (String, BigDecimal
и Collection<?>):
```xml
public class SizeValidatorForString implements<Size, String> {...}
public class SizeValidatorForBigDecimal implements<Size, BigDecimal> {...}
public class SizeValidatorForCollection implements<Size, Collection<?>> {...}
```
###Применение ограничения
Когда у вас есть аннотация и ее реализация, вы можете применять ограничение
с элементом заданного типа (атрибут, конструктор, параметр, возвращаемое значение,
компонент, интерфейс или аннотация). Это решение, которое разработчик прини-
мает на этапе проектирования иреализует с помощью метааннотации @Target(Element-
Type.*) (см. листинг 3.2). Существуют следующие типы:
* FIELD — для ограниченных атрибутов;
* METHOD — для ограниченных геттеров и возвращаемых значений ограниченных
методов;
* CONSTRUCTOR — для возвращаемых значений ограниченных конструкторов;
* PARAMETER — для параметров ограниченных методов и конструкторов;
* TYPE — для ограниченных компонентов, интерфейсов и суперклассов;
* ANNOTATION_TYPE — для ограничений, состоящих из других ограничений.

Как видите, ограничивающие аннотации могут применяться с большинством
типов элементов, определяемых в Java. Только статические поля и статические
методы не могут проверяться валидацией компонентов. В листинге 3.4 показан
класс Order, где ограничивающие аннотации применяются к самому классу, атри-
бутам, конструктору и бизнес-методу.
```xml
@ChronologicalDates
public class Order {
    @NotNull @Pattern(regexp = "[C,D,M][A-Z][0-9]*")
    private String orderId;
    private Date creationDate;
    @Min(1)
    private Double totalAmount;
    private Date paymentDate;
    private Date deliveryDate;
    private List<OrderLine> orderLines;
    public Order() {
    }
    public Order(@Past Date creationDate) {
        this.creationDate = creationDate;
    }
    public @NotNull Double calculateTotalAmount(@GreaterThanZero Double
                                                        changeRate) {
// ...
    }
// Геттеры и сеттеры
}
```
В листинге 3.4 @ChronologicalDates — это ограничение, действующее на уров-
не класса и основанное на нескольких свойствах класса Order (в данном случае
оно гарантирует, что значения creationDate, paymentDate и deliveryDate являются
хронологическими). Атрибут orderId имеет два ограничения: он не может быть
равен нулю (@NotNull) и должен соответствовать шаблону регулярного выраже-
ния (@Pattern). Конструктор Order гарантирует, что параметр creationDate должен
обозначать момент в прошлом. Метод calculateTotalAmount (рассчитывающий
общую сумму заказа на покупку) проверяет, является ли changeRate значением
больше нуля — @GreaterThanZero, а также гарантирует, что возвращаемая сумма
будет ненулевой.